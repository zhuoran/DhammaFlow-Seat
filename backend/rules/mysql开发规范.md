# 一.Mysql开发规范

## 制定规范目的

为了保障业务高性能.稳定运行，需要保障数据库高性能.高可用；

也为了指导研发正确理解MYSQL，提升开发效率，特制定以下规范

以下规范会按照【高危】.【强制】.【建议】三个级别进行标注，遵守优先级从高到低。对于不满足【高危】和【强制】两个级别的设计，DBA会强制打回要求修改

---

# 二.命名规范

1. 【强制】库名.表名.字段名必须使用小写字母.数字并采用下划线分割；
2. 【强制】库名.表名.字段名禁止超过32个字符，须见名知意；
3. 【强制】库的名称格式：业务系统名称_子系统名，同一模块使用的表名尽量使用统一前缀。
4. 【强制】表名要求模块名强相关，如师资系统采用"sz"作为前缀，渠道系统采用"qd"作为前缀等。
5. 【强制】库名.表名.字段名禁止使用MySQL保留关键字；
6. 【强制】临时库.临时表名必须以tmp为前缀并以日期为后缀；使用完成后及时删除
7. 【强制】备份库.备份表名必须以bak为前缀并以日期为后缀；使用完成后及时删除

---

# 三.基本规范

1. 【强制】使用INNODB存储引擎  
   5.5以后的默认引擎，支持事务，行级锁，更好的恢复性，高并发下性能更好，对多核，大内存，ssd等硬件支持更好；原则上不允许使用其它存储引擎
2. 【强制】创建数据库时必须显式指定字符集，并且字符集utf8mb4
3. 【强制】创建表时必须显式指定字符集为utf8mb4
4. 【强制】数据库本身库.表.列所有字符集必须保持一致，为utf8mb4。
5. 【强制】建表必须有comment
6. 【建议】单表数据量建议控制在1000万以内；
7. 【强制】要求主键为id，类型为int或bigint，且为auto_increment;  
   主键选择非业务相关列,并禁止被更新
8. 【建议】表中所有字段必须都是NOT NULL属性，业务可以根据需要定义DEFAULT值。  

   **解读：**  
   1) 目前mysql行存储模式compact,存储结构如下：
      ```
      变长字段
      Null标志位
      记录头信息
      数据1
      数据2
      ```
      2字节 有null，占1字节每行数据，NULL多占1字节空间  
   2) 对null 的处理时候，只能采用is null或is not null，而不能采用=.in.<.<>.!=.not in这些操作符号；  
      如果存在name为null值的记录，查询结果就不会包含name为null值的记录；  
   3) 如果使用order by子句按升序对结果集进行排序，则MySQL认为NULL值低于其他值，因此，它会首先显示NULL值
9. 【强制】不在数据库中存储图片.文件等大数据；  
   不允许字段类型为text.blob等
10. 【高危】禁止在线上做数据库压力测试；
11. 【高危】禁止从测试.开发环境直连数据库；
12. 【建议】单表字段数控制在20个以内
13. 【高危】前端程序字符集或者环境变量中的字符集，与数据库.表的字符集必须一致，统一为utf8mb4；以下几个参数必须统一：
    - character_set_client  
    - character_set_connection  
    - 默认的内部操作字符集  
    - character_set_results  
    - character_set_server  
    - character_set_system  

---

# 四.库表设计规范

1.【建议】必须使用varchar(20)存储手机号；  
   解读：  
   1）涉及到区号或者国家代号，可能出现+-()  
   2）varchar可以支持模糊查询，例如：like"138%"；

2.【建议】拆分大字段和访问频率低的字段，分离冷热数据

3.【建议】业务中选择性很少的状态status.类型type等字段推荐使用tinytint或者smallint类型节省存储空间。

4.【建议】业务中IP地址字段推荐使用无符号int类型，不推荐用char(15)  
   解读：  
   int只占4字节，可以用如下函数相互转换，而char(15)占用至少15字节。一旦表数据行数到了1亿，那么要多用1.1G存储空间  
   SQL：  
   `select inet_aton('192.168.2.12');`  
   `select inet_ntoa(3232236044);`

5.【强制】禁止使用enum.set类型，推荐使用tinyint  
   解读：  
   1）使用编码插入enum的值，不加引号是数字，数字就是key，不是value  
   2）增加新的ENUM值要做DDL操作；  
   3）可能存在业务误插入情况，可能存在业务报错情况

6.【建议】时间类型尽量选取datetime  
   解读：  
   1）mysql5.6.4之后datetime 支持更新当前时间，大小从8字节变为了5字节，和timestamp为4字节，存储空间差不多；  
   2）datetime的范围更大，无时区问题。

8.【建议】用HASH进行散表，下标从0开始  
   首次分表尽量多的分，避免二次分表，二次分表的难度和成本较高

9.【建议】按日期时间分表需符合YYYY[MM][DD][HH]格式

10.【建议】采用合适的分库分表策略，如十库百表等

11.【建议】每个表字段  
   
   ```sql
   create_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'  
   update_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间'
   
   ```
  
12.【强制】禁止使用外建.存储过程.TRIGER

13.【强制】表名及表中的各个字段必须要有comment注释

---


# 五.索引设计规范

索引是一把双刃剑，它可以提高查询效率但也会降低插入和更新的速度并占用磁盘空间

1. 【建议】单张表中索引数量不超过5个
2. 【建议】单个索引中的字段数不超过5个
3. 【建议】对字符串使用前缀索引，前缀索引长度不超过10个字符；  
   如果有一个CHAR(200)列，如果在前10个字符内，多数值是惟一的，那么就不要对整个列进行索引。对前10个字符进行索引能够节省大量索引空间，也可能会使查询更快
4. 【强制】主键的名称以"pk_"开头，唯一键以"uniq_"开头，普通索引以"idx_"开头，一律使用小写格式，以表名/字段的名称或缩写作为后缀
5. 【强制】不使用UUID.MD5.HASH作为主键
6. 【强制】区分度最大的字段放在索引前面
7. 【建议】核心SQL优先考虑覆盖索引  
   select的数据列只用从索引中就能够取得，不必读取数据行
8. 【建议】避免冗余或重复索引  
   index(a,b,c)相当于index(a).index(a,b)
9. 【强制】不在低基数列上建立索引，例如‘性别’
10. 【强制】不在索引列进行数学运算和函数运算
11. 【强制】不要使用外键  
    外键用来保护参照完整性，可在业务端实现；对父表和子表的操作会相互影响，降低可用性；会造成锁等待
12. 【强制】不使用%前导的查询，如`like "%xxx"`，无法使用索引
13. 【建议】不使用反向查询，如`not in` / `not like`
14. 【强制】根据业务查询需求，表中必须要有普通索引或唯一索引，如果没有，需要详细说明原因  
    无法使用索引，导致全表扫描；全表扫描导致buffer pool利用降低

---

# 六.字段设计规范

1. 【建议】用DECIMAL代替FLOAT和DOUBLE存储精确浮点数  
   浮点数可能引起精度问题
2. 【建议】如果可能，把字符转化为数字存储，更高效
3. 【建议】字段长度尽量按实际需要进行分配，不要随意分配很大的容量  
   - VARCHAR(N) 中 N 表示字符数不是字节数  
   - N尽可能小，因为MySQL一个表中所有的VARCHAR字段最大长度是65535个字节
4. 【建议】使用UNSIGNED存储非负整数  
   同样的字节数，存储范围更大
5. 【建议】使用VARBINARY存储大小写敏感的变长字符串
6. 【高危】禁止在数据库中存储明文密码

---

# 七.SQL设计规范

1. 【建议】使用预编译语句prepared statement  
   一次解析，多次使用
2. 【建议】尽量避免相同语句因书写格式不同而多次语法分析
3. 【强制】避免隐式转换  
   会导致索引失效  
   MySQL隐式类型转换规则较复杂且耗性能，不推荐依赖
4. 【强制】insert语句指定具体字段名称，不要写成`insert into t1 values(...)`
5. 【强制】不要在WHERE条件的属性上使用函数或表达式，无法使用索引  
   - 错误示例：`where from_unixtime(day) >= '2017-02-15'`  
   - 正确示例：`where day >= unix_timestamp('2017-02-15 00:00:00')`
6. 【禁止】多个大表的关联查询  
   join或子查询在大数据量下效率低
7. 【强制】DML语句必须有where条件
8. 【建议】DDL及DML语句中禁止使用子查询
9. 【建议】减少与数据库的交互次数  
   - insert...on duplicate key update  
   - replace into  
   - 批量insert/update
10. 【建议】拒绝大SQL，拆分成小SQL
11. 【建议】减少使用order by，可放程序端排序
12. 【高危】禁用`update|delete ... where ... limit ...`
13. 【建议】order by.group by.distinct尽量利用索引直接检索排序好的数据
14. 【强制】使用in代替or，in的值不超过1000个
15. 【强制】禁止使用order by rand()
16. 【强制】使用union all而不是union
17. 【建议】程序应有捕获SQL异常的处理机制
18. 【高危】禁止联表更新语句，如`update t1,t2 where t1.id=t2.id`
19. 【强制】不使用select *，写明具体列名

---

# 八.行为规范

1. 【强制】批量导入.导出数据必须提前通知DBA协助观察；
2. 【强制】禁止在业务从库上执行后台管理和统计类的功能查询；
3. 【强制】禁止有super权限的应用程序账号存在；
4. 【建议】产品出现非数据库导致的故障时及时通知DBA协助排查；
5. 【强制】促销活动或上线新功能必须提前通知DBA进行流量评估；
6. 【建议】数据库数据丢失，及时联系DBA进行排查及恢复；
7. 【建议】对单表的多次alter操作须合并为一次操作；
8. 【强制】重大项目的数据库方案选型和设计须提前通知DBA参与；
9. 【强制】对特别重要的库表，提前与DBA沟通确定维护和备份优先级；
10. 【强制】不在业务高峰期批量更新.查询数据库；

