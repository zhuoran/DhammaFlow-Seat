# Spring Boot 3 + Java 17 Web API 接口实现最佳实践规范

## 1. 技术栈与环境
- **语言**：Java 17（LTS 版本，sealed classes、record 等新特性可用）
- **框架**：Spring Boot 3.x
- **构建工具**：Maven 或 Gradle
- **持久层**：Spring Data JPA / MyBatis-Plus
- **数据库**：MySQL 8.x / PostgreSQL 15+
- **API 文档**：Springdoc OpenAPI (Swagger 3)
- **测试**：JUnit 5 + Mockito
- **日志**：SLF4J + Logback
- **安全**：Spring Security 6.x / OAuth2 / JWT

---

## 2. 项目分层架构

```
com.example.project
├── api             // Controller 层
├── service         // Service 接口层
├── service.impl    // Service 实现层
├── repository      // 数据访问层（DAO）
├── domain          // 领域模型（Entity / VO / DTO）
│   ├── entity
│   ├── dto
│   ├── vo
├── config          // 配置类
├── exception       // 自定义异常
├── util            // 工具类
└── common          // 公共常量、枚举、返回结构
```

---

## 3. Controller 层规范
- **职责**：接收请求参数，调用 Service，返回统一响应
- **不要**直接操作数据库
- 参数验证：使用 `@Valid` 和 `@Validated`
- RESTful 风格：
  - `GET /users/{id}`   → 查询用户
  - `POST /users`       → 创建用户
  - `PUT /users/{id}`   → 更新用户
  - `DELETE /users/{id}`→ 删除用户

示例：

```java
@RestController
@RequestMapping("/api/v1/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping("/{id}")
    public ResponseResult<UserVO> getUser(@PathVariable Long id) {
        return ResponseResult.success(userService.getUserById(id));
    }

    @PostMapping
    public ResponseResult<UserVO> createUser(@Valid @RequestBody UserDTO dto) {
        return ResponseResult.success(userService.createUser(dto));
    }
}
```

---

## 4. Service 层规范
- **职责**：业务逻辑实现
- **禁止**返回数据库实体直接暴露给前端（使用 VO/DTO）
- 事务管理：使用 `@Transactional`
- 接口 + 实现 分离

示例：

```java
public interface UserService {
    UserVO getUserById(Long id);
    UserVO createUser(UserDTO dto);
}

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UserRepository repository;

    @Override
    public UserVO getUserById(Long id) {
        return repository.findById(id)
                .map(UserVO::fromEntity)
                .orElseThrow(() -> new NotFoundException("用户不存在"));
    }

    @Override
    @Transactional
    public UserVO createUser(UserDTO dto) {
        UserEntity entity = UserEntity.fromDTO(dto);
        return UserVO.fromEntity(repository.save(entity));
    }
}
```

---

## 5. 数据传输对象（DTO / VO / Entity）
- **Entity** → 数据库映射
- **DTO** → 接收前端传入数据
- **VO** → 返回给前端的数据
- **禁止**直接返回 Entity

示例：

```java
public record UserDTO(
        @NotBlank String username,
        @Email String email
) {}

public record UserVO(
        Long id,
        String username,
        String email
) {
    public static UserVO fromEntity(UserEntity entity) {
        return new UserVO(entity.getId(), entity.getUsername(), entity.getEmail());
    }
}
```

---

## 6. 统一响应结构
规范：

```json
{
  "code": 0,
  "message": "success",
  "data": {}
}
```

实现：

```java
public record ResponseResult<T>(int code, String message, T data) {

    public static <T> ResponseResult<T> success(T data) {
        return new ResponseResult<>(0, "success", data);
    }

    public static <T> ResponseResult<T> failure(int code, String message) {
        return new ResponseResult<>(code, message, null);
    }
}
```

---

## 7. 全局异常处理
- 统一捕获业务异常和系统异常
- 使用 `@RestControllerAdvice`

示例：

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NotFoundException.class)
    public ResponseResult<Void> handleNotFound(NotFoundException e) {
        return ResponseResult.failure(404, e.getMessage());
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseResult<Void> handleValidation(MethodArgumentNotValidException e) {
        String msg = e.getBindingResult().getFieldError().getDefaultMessage();
        return ResponseResult.failure(400, msg);
    }

    @ExceptionHandler(Exception.class)
    public ResponseResult<Void> handleGeneric(Exception e) {
        return ResponseResult.failure(500, "系统异常");
    }
}
```

---

## 8. 分页与排序
- 使用 Spring Data `Pageable`
- 返回统一分页结构

示例：

```java
public record PageResult<T>(List<T> records, long total, int page, int size) {}

@GetMapping
public ResponseResult<PageResult<UserVO>> listUsers(Pageable pageable) {
    Page<UserEntity> page = repository.findAll(pageable);
    return ResponseResult.success(
        new PageResult<>(
            page.getContent().stream().map(UserVO::fromEntity).toList(),
            page.getTotalElements(),
            pageable.getPageNumber(),
            pageable.getPageSize()
        )
    );
}
```

---

## 9. 日志规范
- 使用 `Slf4j` 记录日志
- 不在日志中记录敏感信息（密码、token 等）
- Controller 记录 API 请求入口
- Service 记录关键业务操作

示例：

```java
@Slf4j
@Service
public class PaymentService {
    public void pay(Order order) {
        log.info("支付订单: {}", order.getId());
        // ...
    }
}
```

---

## 10. API 文档
- 使用 `springdoc-openapi-starter-webmvc-ui`
- 配置示例：

```java
@OpenAPIDefinition(
    info = @Info(title = "用户服务 API", version = "1.0", description = "用户相关接口")
)
@SpringBootApplication
public class Application {}
```

访问地址：`/swagger-ui.html`

---

## 11. 安全与认证
- 使用 Spring Security + JWT
- API 需鉴权，白名单接口在 `SecurityConfig` 中配置
- 密码加密存储（`BCryptPasswordEncoder`）

---

## 12. 单元测试
- 使用 `@SpringBootTest`
- Service 层 Mock Repository
- Controller 层用 MockMvc 测试

---

## 13. 编码风格
- 遵循 阿里巴巴 Java 开发手册
- 类命名、方法命名见名知意
- 常量使用 `UPPER_CASE`
- 魔法值提取为常量或枚举

---

## 14. CI/CD 与部署
- CI 使用 GitHub Actions / Jenkins
- 自动化构建、测试、部署
- Docker 容器化部署，使用 multi-stage build
